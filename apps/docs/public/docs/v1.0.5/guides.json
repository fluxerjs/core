[
  {
    "id": "installation",
    "slug": "installation",
    "title": "Installation",
    "description": "Install the package and configure your bot token.",
    "category": "getting-started",
    "sections": [
      {
        "code": "npm install @fluxerjs/core\n\n# Run your bot (Node 18+)\nFLUXER_BOT_TOKEN=your_token node your-bot.js",
        "language": "bash"
      }
    ]
  },
  {
    "id": "basic-bot",
    "slug": "basic-bot",
    "title": "Basic Bot",
    "description": "A minimal bot that responds to !ping with Pong.",
    "category": "getting-started",
    "sections": [
      {
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.Ready, () => console.log('Ready!'));\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!ping') {\n    await message.reply('Pong!');\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "embeds",
    "slug": "embeds",
    "title": "Embeds",
    "description": "Send rich embeds with EmbedBuilder.",
    "category": "sending-messages",
    "sections": [
      {
        "code": "import { Client, Events, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!embed') {\n    const embed = new EmbedBuilder()\n      .setTitle('Hello!')\n      .setDescription('This is a Fluxer embed.')\n      .setColor(0x5865f2)\n      .addFields(\n        { name: 'Field 1', value: 'Value 1', inline: true },\n        { name: 'Field 2', value: 'Value 2', inline: true }\n      )\n      .setFooter({ text: 'Powered by Fluxer.js' })\n      .setTimestamp();\n\n    await message.reply({ embeds: [embed.toJSON()] });\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "editing-embeds",
    "slug": "editing-embeds",
    "title": "Editing Embeds",
    "description": "Edit existing message embeds with message.edit().",
    "category": "sending-messages",
    "sections": [
      {
        "title": "Overview",
        "description": "The Fluxer API supports editing existing messages via PATCH. You can update the message content, embeds, or both. Only the message author (or admins with proper permissions) can edit messages."
      },
      {
        "title": "Edit Content",
        "description": "Update the text content of a message you sent.",
        "code": "const reply = await message.reply('Initial message');\nawait reply.edit({ content: 'Updated message!' });",
        "language": "javascript"
      },
      {
        "title": "Edit Embeds",
        "description": "Replace or update embeds on an existing message. Pass an array of EmbedBuilder instances or APIEmbed objects.",
        "code": "import { Client, Events, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!editembed') {\n    const embed = new EmbedBuilder()\n      .setTitle('Loading...')\n      .setColor(0x5865f2)\n      .setTimestamp();\n\n    const reply = await message.reply({ embeds: [embed.toJSON()] });\n\n    // Simulate loading, then update the embed\n    await new Promise((r) => setTimeout(r, 2000));\n\n    const updatedEmbed = new EmbedBuilder()\n      .setTitle('Done!')\n      .setDescription('This embed was edited after 2 seconds.')\n      .setColor(0x57f287)\n      .setTimestamp();\n\n    await reply.edit({ embeds: [updatedEmbed] });\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Edit Content and Embeds Together",
        "description": "You can update both content and embeds in a single edit call.",
        "code": "await message.edit({\n  content: 'Updated text',\n  embeds: [new EmbedBuilder().setTitle('Updated embed').setColor(0x5865f2).toJSON()],\n});",
        "language": "javascript"
      },
      {
        "title": "API Reference",
        "description": "The edit endpoint is PATCH /channels/{channel_id}/messages/{message_id}. See openapi.json for the full request body schema. The SDK Message.edit() accepts { content?: string; embeds?: (APIEmbed | EmbedBuilder)[] }."
      }
    ]
  },
  {
    "id": "webhooks",
    "slug": "webhooks",
    "title": "Webhooks",
    "description": "A complete guide to Discord webhooksâ€”sending messages without a gateway, creating webhooks, and managing them.",
    "category": "webhooks",
    "sections": [
      {
        "title": "What are Webhooks?",
        "description": "Webhooks let you send messages to a channel using a URL (ID + token). You can use them in scripts, CI pipelines, or anywhere you need to post without a full bot connection. No gateway, no eventsâ€”just REST."
      },
      {
        "title": "Webhooks Without a Bot",
        "description": "A Client with intents: 0 is enough. No need to connect to the gateway or handle events. Ideal for scripts or one-off sends.",
        "code": "import { Client, Webhook } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst webhook = Webhook.fromToken(client, webhookId, webhookToken);\nawait webhook.send('Message from a script!');",
        "language": "javascript"
      },
      {
        "title": "Creating a Webhook",
        "description": "Create a webhook on a text channel. Requires Manage Webhooks permission. The token is returned only when creatingâ€”store it securely. It will never be returned when listing or fetching.",
        "code": "import { Client } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\nconst channel = client.channels.get(channelId);\nif (!channel?.createWebhook) throw new Error('Channel does not support webhooks');\n\nconst webhook = await channel.createWebhook({ name: 'My Webhook' });\nconsole.log(webhook.id, webhook.token); // Store tokenâ€”it won't be returned when listing",
        "language": "javascript"
      },
      {
        "title": "Sending Messages",
        "description": "Send text, embeds, or both. You can override the username and avatar for each message.",
        "code": "import { Client, Webhook, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst webhook = Webhook.fromToken(client, webhookId, webhookToken);\n\nawait webhook.send({\n  content: 'Hello from webhook!',\n  embeds: [\n    new EmbedBuilder()\n      .setTitle('Webhook Message')\n      .setColor(0x5865f2)\n      .setTimestamp()\n      .toJSON(),\n  ],\n  username: 'Custom Name',\n  avatar_url: 'https://example.com/avatar.png',\n});",
        "language": "javascript"
      },
      {
        "title": "Simple text only",
        "code": "await webhook.send('Plain text message');",
        "language": "javascript"
      },
      {
        "title": "Fetching & Listing Webhooks",
        "description": "Fetch by ID or list channel/guild webhooks. Requires a logged-in bot. Fetched webhooks have no token and cannot sendâ€”only manage (delete).",
        "code": "import { Client, Webhook } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\n// Fetch single webhook (no token)\nconst webhook = await Webhook.fetch(client, webhookId);\n\n// List channel webhooks\nconst channel = client.channels.get(channelId);\nconst channelWebhooks = await channel?.fetchWebhooks() ?? [];\n\n// List guild webhooks\nconst guild = client.guilds.get(guildId);\nconst guildWebhooks = await guild?.fetchWebhooks() ?? [];",
        "language": "javascript"
      },
      {
        "title": "Deleting a Webhook",
        "code": "const webhook = await Webhook.fetch(client, webhookId);\nawait webhook.delete();",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "voice",
    "slug": "voice",
    "title": "Voice",
    "description": "Join voice channels and play audio with @fluxerjs/voice. Supports WebM/Opus streamsâ€”no FFmpeg required.",
    "category": "voice",
    "sections": [
      {
        "title": "Installation",
        "description": "Add the voice package alongside the core library.",
        "code": "pnpm add @fluxerjs/voice @fluxerjs/core",
        "language": "bash"
      },
      {
        "title": "Setup",
        "description": "Create a VoiceManager before login so it receives VoiceStatesSync from READY/GUILD_CREATE. This lets the manager see users already in voice when the bot starts.",
        "code": "import { Client, Events, VoiceChannel } from '@fluxerjs/core';\nimport { getVoiceManager } from '@fluxerjs/voice';\n\nconst client = new Client({ intents: 0 });\ngetVoiceManager(client); // Must be before login\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Join a Voice Channel",
        "description": "Get the user's voice channel with getVoiceChannelId, then join. The connection resolves when ready.",
        "code": "const voiceManager = getVoiceManager(client);\nconst voiceChannelId = voiceManager.getVoiceChannelId(guildId, userId);\nif (!voiceChannelId) {\n  return; // User not in voice\n}\n\nconst channel = client.channels.get(voiceChannelId);\nif (!channel || !(channel instanceof VoiceChannel)) {\n  return;\n}\n\nconst connection = await voiceManager.join(channel);",
        "language": "javascript"
      },
      {
        "title": "Play Audio",
        "description": "Play a WebM/Opus URL or stream. The voice package does not use FFmpegâ€”input must be WebM with Opus. Use yt-dlp or similar to get direct stream URLs from YouTube.",
        "code": "// URL (fetched and demuxed automatically)\nawait connection.play('https://example.com/audio.webm');\n\n// Or a Node.js ReadableStream of Opus\nawait connection.play(opusStream);",
        "language": "javascript"
      },
      {
        "title": "Getting Stream URLs from YouTube",
        "description": "Use youtube-dl-exec or yt-dlp to extract a WebM/Opus URL.",
        "code": "import youtubedl from 'youtube-dl-exec';\n\nconst result = await youtubedl(videoUrl, {\n  getUrl: true,\n  f: 'bestaudio[ext=webm][acodec=opus]/bestaudio[ext=webm]/bestaudio',\n}, { timeout: 15000 });\n\nconst streamUrl = String(result ?? '').trim();\nawait connection.play(streamUrl);",
        "language": "javascript"
      },
      {
        "title": "Stop and Leave",
        "description": "Stop playback and disconnect from the guild's voice channel.",
        "code": "const connection = voiceManager.getConnection(guildId);\nif (connection) {\n  connection.stop();\n  voiceManager.leave(guildId);\n}",
        "language": "javascript"
      },
      {
        "title": "LiveKit and serverLeave",
        "description": "If using LiveKit, the server may emit serverLeave. Listen and reconnect if needed.",
        "code": "connection.on?.('serverLeave', async () => {\n  try {\n    const conn = await voiceManager.join(channel);\n    await conn.play(streamUrl);\n  } catch (e) {\n    console.error('Auto-reconnect failed:', e);\n  }\n});",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "events",
    "slug": "events",
    "title": "Events",
    "description": "Listen to gateway events with client.on. Handle messages, guild updates, voice state changes, and more.",
    "category": "events",
    "sections": [
      {
        "title": "Basic Usage",
        "description": "Use client.on(Events.X, handler) to subscribe to events. Handlers receive event-specific payloads.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.Ready, () => {\n  console.log('Bot is ready!');\n});\n\nclient.on(Events.MessageCreate, async (message) => {\n  console.log(message.content);\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Common Events",
        "description": "Essential events for most bots.",
        "code": "// Bot finished loading\nclient.on(Events.Ready, () => {});\n\n// New message (DM or guild)\nclient.on(Events.MessageCreate, async (message) => {});\n\n// Reaction events\nclient.on(Events.MessageReactionAdd, (data) => {});\nclient.on(Events.MessageReactionRemove, (data) => {});\n\n// Guild joined/left/updated\nclient.on(Events.GuildCreate, (guild) => {});\nclient.on(Events.GuildDelete, (guild) => {});\n\n// Channel created/updated/deleted\nclient.on(Events.ChannelCreate, (channel) => {});\nclient.on(Events.ChannelDelete, (channel) => {});\n\n// Member joined/left/updated\nclient.on(Events.GuildMemberAdd, (member) => {});\nclient.on(Events.GuildMemberRemove, (member) => {});\n\n// Voice state changed (for @fluxerjs/voice)\nclient.on(Events.VoiceStateUpdate, (data) => {});\nclient.on(Events.VoiceServerUpdate, (data) => {});",
        "language": "javascript"
      },
      {
        "title": "Reaction Events",
        "description": "Listen for when users add or remove reactions. The payload includes message_id, channel_id, user_id, and emoji (name and optional id for custom emojis). Use MessageReactionRemoveAll and MessageReactionRemoveEmoji for moderator actions.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageReactionAdd, (data) => {\n  const { message_id, channel_id, user_id, emoji } = data;\n  const emojiStr = emoji.id ? `<:${emoji.name}:${emoji.id}>` : emoji.name;\n  console.log(`User ${user_id} reacted with ${emojiStr} on message ${message_id}`);\n\n  // Filter for specific message (e.g. poll) or emoji\n  if (data.emoji.name === 'ðŸ‘') {\n    console.log('Someone voted yes!');\n  }\n});\n\nclient.on(Events.MessageReactionRemove, (data) => {\n  const { message_id, user_id, emoji } = data;\n  console.log(`User ${user_id} removed ${emoji.name} from message ${message_id}`);\n});\n\nclient.on(Events.MessageReactionRemoveAll, (data) => {\n  console.log(`All reactions cleared from message ${data.message_id}`);\n});\n\nclient.on(Events.MessageReactionRemoveEmoji, (data) => {\n  console.log(`All ${data.emoji.name} reactions removed from message ${data.message_id}`);\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Error Handling",
        "code": "client.on(Events.Error, (err) => {\n  console.error('Client error:', err);\n});",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "prefix-commands",
    "slug": "prefix-commands",
    "title": "Prefix Commands",
    "description": "Handle !commands by listening to MessageCreate and parsing the content.",
    "category": "events",
    "sections": [
      {
        "title": "Basic Structure",
        "description": "Check for a prefix, split args, and dispatch to command handlers.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst PREFIX = '!';\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.author.bot || !message.content) return;\n  if (!message.content.startsWith(PREFIX)) return;\n\n  const args = message.content.slice(PREFIX.length).trim().split(/\\s+/);\n  const command = args.shift()?.toLowerCase();\n\n  if (command === 'ping') {\n    await message.reply('Pong!');\n  }\n  if (command === 'hello') {\n    const name = args[0] ?? 'there';\n    await message.reply(`Hello, ${name}!`);\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Guild-Only Commands",
        "code": "if (!message.guildId) {\n  await message.reply('This command only works in a server.');\n  return;\n}",
        "language": "javascript"
      }
    ]
  }
]
