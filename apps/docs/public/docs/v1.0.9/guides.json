[
  {
    "id": "installation",
    "slug": "installation",
    "title": "Installation",
    "description": "Install the package and configure your bot token.",
    "category": "getting-started",
    "sections": [
      {
        "code": "npm install @fluxerjs/core\n\n# Run your bot (Node 18+)\nFLUXER_BOT_TOKEN=your_token node your-bot.js",
        "language": "bash"
      }
    ]
  },
  {
    "id": "basic-bot",
    "slug": "basic-bot",
    "title": "Basic Bot",
    "description": "A minimal bot that responds to !ping with Pong.",
    "category": "getting-started",
    "sections": [
      {
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.Ready, () => console.log('Ready!'));\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!ping') {\n    await message.reply('Pong!');\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "sending-without-reply",
    "slug": "sending-without-reply",
    "title": "Sending Without Reply",
    "description": "Send messages to the same channel or to specific channels. Covers message.send(), message.sendTo(), client.channels.send(), and client.channels.fetch().",
    "category": "sending-messages",
    "sections": [
      {
        "title": "message.send() vs message.reply()",
        "description": "message.reply() sends a message that references another message (shows as a \"reply\" in Discord). message.send() sends to the same channel with no referenceâ€”a regular standalone message."
      },
      {
        "title": "Sending to the same channel",
        "description": "Use message.send() when you want to post in the channel without replying. Same signature as reply(): pass a string or object with content and/or embeds.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!hello') {\n    await message.send('Hello! This is a regular message, not a reply.');\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Sending to a specific channel (e.g. logging)",
        "description": "Use message.sendTo(channelId, payload) to send to another channelâ€”handy for logging, announcements, or forwarding. You only need the target channel ID.",
        "code": "import { Client, Events, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst LOG_CHANNEL_ID = process.env.LOG_CHANNEL_ID; // Your log channel's snowflake\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!report' && message.guildId && LOG_CHANNEL_ID) {\n    const embed = new EmbedBuilder()\n      .setTitle('User report')\n      .setDescription(message.content)\n      .addFields(\n        { name: 'Author', value: message.author.username, inline: true },\n        { name: 'Channel', value: `<#${message.channelId}>`, inline: true }\n      )\n      .setTimestamp();\n\n    await message.sendTo(LOG_CHANNEL_ID, { embeds: [embed.toJSON()] });\n    await message.send('Report logged.');\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "client.channels.send() â€” send by channel ID",
        "description": "Use client.channels.send(channelId, payload) when you have a channel ID. Works even if the channel is not cached. No need to fetch first when you only need to send.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst ANNOUNCE_CHANNEL_ID = process.env.ANNOUNCE_CHANNEL_ID;\n\nclient.on(Events.Ready, async () => {\n  if (ANNOUNCE_CHANNEL_ID) {\n    await client.channels.send(ANNOUNCE_CHANNEL_ID, 'Bot is online!');\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "client.channels.fetch() â€” get channel by ID",
        "description": "Fetch a channel by ID from the API (or cache). Use channel.isSendable() before sending. For sending when you only have an ID, prefer client.channels.send() which skips the fetch.",
        "code": "import { Client } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\n// Fetch channel (from API if not cached)\nconst channel = await client.channels.fetch(channelId);\nif (channel?.isSendable()) {\n  await channel.send('Hello!');\n}\n// Or for webhooks: if (channel?.createWebhook) { ... }",
        "language": "javascript"
      },
      {
        "title": "fetch message by id",
        "description": "Use channel.messages.fetch(messageId) when you have the channel. For IDs-only, fetch the channel first.",
        "code": "// When you have the channel\nconst message = await channel.messages.fetch(messageId);\nif (message) {\n  await message.edit({ content: 'Updated!' });\n  await message.react('ðŸ‘');\n}\n\n// When you only have IDs (e.g. from sqlite)\nconst ch = await client.channels.fetch(channelId);\nconst msg = await ch?.messages?.fetch(messageId);\nif (msg) await msg.delete();\n\n// When channel is cached\nconst m = client.channels.get(channelId);\nif (m?.isSendable()) {\n  const mes = await m.messages.fetch(messageId);\n  if (mes) await mes.edit({ content: 'Edited!' });\n}\n\n// Refresh a stale message instance\nconst updated = await message.fetch();\nif (updated) console.log(updated.content);",
        "language": "javascript"
      },
      {
        "title": "message.channel and message.guild",
        "description": "Access the channel or guild from a message. Resolved from cache; null if not cached (e.g. DM channel).",
        "code": "client.on(Events.MessageCreate, async (message) => {\n  const channel = message.channel;   // TextChannel or DMChannel | null\n  const guild = message.guild;       // Guild | null (null for DMs)\n  if (message.channel?.isSendable()) {\n    await message.channel.send('Same channel, different API');\n  }\n});",
        "language": "javascript"
      },
      {
        "title": "Quick reference",
        "code": "// Same channel, no reply\nawait message.send('Pong!');\n\n// Reply to the message\nawait message.reply('Pong!');\n\n// Send to a specific channel\nawait message.sendTo(logChannelId, 'User joined!');\nawait client.channels.send(channelId, 'New update available!');",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "embeds",
    "slug": "embeds",
    "title": "Embeds",
    "description": "Send rich embeds with EmbedBuilder.",
    "category": "sending-messages",
    "sections": [
      {
        "code": "import { Client, Events, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!embed') {\n    const embed = new EmbedBuilder()\n      .setTitle('Hello!')\n      .setDescription('This is a Fluxer embed.')\n      .setColor(0x5865f2)\n      .addFields(\n        { name: 'Field 1', value: 'Value 1', inline: true },\n        { name: 'Field 2', value: 'Value 2', inline: true }\n      )\n      .setFooter({ text: 'Powered by Fluxer.js' })\n      .setTimestamp();\n\n    await message.reply({ embeds: [embed.toJSON()] });\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "editing-embeds",
    "slug": "editing-embeds",
    "title": "Editing Embeds",
    "description": "Edit existing message embeds with message.edit().",
    "category": "sending-messages",
    "sections": [
      {
        "title": "Overview",
        "description": "The Fluxer API supports editing existing messages via PATCH. You can update the message content, embeds, or both. Only the message author (or admins with proper permissions) can edit messages."
      },
      {
        "title": "Edit Content",
        "description": "Update the text content of a message you sent.",
        "code": "const reply = await message.reply('Initial message');\nawait reply.edit({ content: 'Updated message!' });",
        "language": "javascript"
      },
      {
        "title": "Edit Embeds",
        "description": "Replace or update embeds on an existing message. Pass an array of EmbedBuilder instances or APIEmbed objects.",
        "code": "import { Client, Events, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.content === '!editembed') {\n    const embed = new EmbedBuilder()\n      .setTitle('Loading...')\n      .setColor(0x5865f2)\n      .setTimestamp();\n\n    const reply = await message.reply({ embeds: [embed.toJSON()] });\n\n    // Simulate loading, then update the embed\n    await new Promise((r) => setTimeout(r, 2000));\n\n    const updatedEmbed = new EmbedBuilder()\n      .setTitle('Done!')\n      .setDescription('This embed was edited after 2 seconds.')\n      .setColor(0x57f287)\n      .setTimestamp();\n\n    await reply.edit({ embeds: [updatedEmbed] });\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Edit Content and Embeds Together",
        "description": "You can update both content and embeds in a single edit call.",
        "code": "await message.edit({\n  content: 'Updated text',\n  embeds: [new EmbedBuilder().setTitle('Updated embed').setColor(0x5865f2).toJSON()],\n});",
        "language": "javascript"
      },
      {
        "title": "API Reference",
        "description": "The edit endpoint is PATCH /channels/{channel_id}/messages/{message_id}. See openapi.json for the full request body schema. The SDK Message.edit() accepts { content?: string; embeds?: (APIEmbed | EmbedBuilder)[] }."
      }
    ]
  },
  {
    "id": "reactions",
    "slug": "reactions",
    "title": "Reactions",
    "description": "Add, remove, and listen for message reactions with Message.react(), removeReaction(), and reaction events.",
    "category": "sending-messages",
    "sections": [
      {
        "title": "Add a Reaction",
        "description": "Use message.react() to add an emoji reaction as the bot. Pass a unicode emoji string or custom emoji { name, id }.",
        "code": "const reply = await message.reply('React to this!');\nawait reply.react('ðŸ‘');\nawait reply.react({ name: 'customemoji', id: '123456789012345678' });",
        "language": "javascript"
      },
      {
        "title": "Remove Reactions",
        "description": "Remove the bot's reaction with removeReaction(emoji). Remove a specific user's reaction with removeReaction(emoji, userId). Clear all reactions with removeAllReactions() or removeReactionEmoji(emoji).",
        "code": "// Remove the bot's reaction\nawait message.removeReaction('ðŸ‘');\n\n// Remove a specific user's reaction (requires moderator permissions)\nawait message.removeReaction('ðŸ‘', userId);\n\n// Remove all reactions of one emoji from the message\nawait message.removeReactionEmoji('ðŸ‘');\n\n// Remove all reactions from the message\nawait message.removeAllReactions();",
        "language": "javascript"
      },
      {
        "title": "Listen for Reactions",
        "description": "MessageReactionAdd and MessageReactionRemove emit (reaction, user). Use reaction.emoji, reaction.messageId, reaction.channelId, reaction.guildId, or reaction.fetchMessage() to get the full message.",
        "code": "client.on(Events.MessageReactionAdd, async (reaction, user) => {\n  if (reaction.emoji.name === 'ðŸ‘') {\n    console.log(`User ${user.id} voted yes on message ${reaction.messageId}`);\n    const message = await reaction.fetchMessage();\n    if (message) await message.react('âœ…');\n  }\n});\n\nclient.on(Events.MessageReactionRemove, (reaction, user) => {\n  console.log(`User ${user.id} removed ${reaction.emoji.name} from message ${reaction.messageId}`);\n});",
        "language": "javascript"
      },
      {
        "title": "Reaction Roles Example",
        "description": "See examples/reaction-roles-bot.js for a full bot that assigns roles when users react to a message. Uses (reaction, user), Guild.fetchMember(), and GuildMember.addRole()/removeRole().",
        "code": "// Simplified reaction-roles logic\nclient.on(Events.MessageReactionAdd, async (reaction, user) => {\n  if (!reaction.guildId || reaction.messageId !== rolesMessageId) return;\n  const roleId = ROLE_EMOJI_MAP[reaction.emoji.name];\n  if (!roleId) return;\n  const guild = client.guilds.get(reaction.guildId);\n  const member = await guild?.fetchMember(user.id);\n  if (member && !member.roles.includes(roleId)) await member.addRole(roleId);\n});",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "webhooks",
    "slug": "webhooks",
    "title": "Webhooks",
    "description": "A complete guide to Discord webhooksâ€”sending messages without a gateway, creating, editing, and managing webhooks.",
    "category": "webhooks",
    "sections": [
      {
        "title": "What are Webhooks?",
        "description": "Webhooks let you send messages to a channel using a URL (ID + token). You can use them in scripts, CI pipelines, or anywhere you need to post without a full bot connection. No gateway, no eventsâ€”just REST."
      },
      {
        "title": "Webhooks Without a Bot",
        "description": "A Client with intents: 0 is enough. No need to connect to the gateway or handle events. Ideal for scripts or one-off sends.",
        "code": "import { Client, Webhook } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst webhook = Webhook.fromToken(client, webhookId, webhookToken);\nawait webhook.send('Message from a script!');",
        "language": "javascript"
      },
      {
        "title": "Creating a Webhook",
        "description": "Create a webhook on a text channel. Requires Manage Webhooks permission. The token is returned only when creatingâ€”store it securely. It will never be returned when listing or fetching.",
        "code": "import { Client } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\nconst channel = client.channels.get(channelId);\nif (!channel?.createWebhook) throw new Error('Channel does not support webhooks');\n\nconst webhook = await channel.createWebhook({ name: 'My Webhook' });\nconsole.log(webhook.id, webhook.token); // Store tokenâ€”it won't be returned when listing",
        "language": "javascript"
      },
      {
        "title": "Sending Messages",
        "description": "Send text, embeds, or both. You can override the username and avatar for each message.",
        "code": "import { Client, Webhook, EmbedBuilder } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nconst webhook = Webhook.fromToken(client, webhookId, webhookToken);\n\nawait webhook.send({\n  content: 'Hello from webhook!',\n  embeds: [\n    new EmbedBuilder()\n      .setTitle('Webhook Message')\n      .setColor(0x5865f2)\n      .setTimestamp()\n      .toJSON(),\n  ],\n  username: 'Custom Name',\n  avatar_url: 'https://example.com/avatar.png',\n});",
        "language": "javascript"
      },
      {
        "title": "Simple text only",
        "code": "await webhook.send('Plain text message');",
        "language": "javascript"
      },
      {
        "title": "Fetching & Listing Webhooks",
        "description": "Fetch by ID or list channel/guild webhooks. Requires a logged-in bot. Fetched webhooks have no token and cannot sendâ€”but you can edit or delete them with bot auth.",
        "code": "import { Client, Webhook } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\n// Fetch single webhook (no token)\nconst webhook = await Webhook.fetch(client, webhookId);\n\n// List channel webhooks\nconst channel = client.channels.get(channelId);\nconst channelWebhooks = await channel?.fetchWebhooks() ?? [];\n\n// List guild webhooks\nconst guild = client.guilds.get(guildId);\nconst guildWebhooks = await guild?.fetchWebhooks() ?? [];",
        "language": "javascript"
      },
      {
        "title": "Editing a Webhook",
        "description": "Use webhook.edit() to change name, avatar, or (with bot auth) channel. With a token (e.g. from createWebhook or fromToken), you can update name and avatar. Without a token (fetched webhook), bot auth lets you also change the target channel.",
        "code": "import { Client, Webhook } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\nawait client.login(process.env.FLUXER_BOT_TOKEN);\n\n// With token (name and avatar only)\nconst webhook = Webhook.fromToken(client, webhookId, webhookToken);\nawait webhook.edit({ name: 'New Name', avatar: null });\n// avatar: null clears the webhook avatar\n\n// With bot auth (fetched webhook â€” can also move to another channel)\nconst fetched = await Webhook.fetch(client, webhookId);\nawait fetched.edit({\n  name: 'Updated Name',\n  channel_id: newChannelId,  // move webhook to different channel\n});",
        "language": "javascript"
      },
      {
        "title": "Deleting a Webhook",
        "code": "const webhook = await Webhook.fetch(client, webhookId);\nawait webhook.delete();",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "voice",
    "slug": "voice",
    "title": "Voice",
    "description": "Join voice channels and play audio with @fluxerjs/voice. Supports WebM/Opus streamsâ€”no FFmpeg required.",
    "category": "voice",
    "sections": [
      {
        "title": "Installation",
        "description": "Add the voice package alongside the core library.",
        "code": "pnpm add @fluxerjs/voice @fluxerjs/core",
        "language": "bash"
      },
      {
        "title": "Setup",
        "description": "Create a VoiceManager before login so it receives VoiceStatesSync from READY/GUILD_CREATE. This lets the manager see users already in voice when the bot starts.",
        "code": "import { Client, Events, VoiceChannel } from '@fluxerjs/core';\nimport { getVoiceManager } from '@fluxerjs/voice';\n\nconst client = new Client({ intents: 0 });\ngetVoiceManager(client); // Must be before login\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Join a Voice Channel",
        "description": "Get the user's voice channel with getVoiceChannelId, then join. The connection resolves when ready.",
        "code": "const voiceManager = getVoiceManager(client);\nconst voiceChannelId = voiceManager.getVoiceChannelId(guildId, userId);\nif (!voiceChannelId) return; // User not in voice\n\nconst channel = client.channels.get(voiceChannelId);\nif (!(channel instanceof VoiceChannel)) return;\n\nconst connection = await voiceManager.join(channel);",
        "language": "javascript"
      },
      {
        "title": "Play Audio",
        "description": "Play a WebM/Opus URL or stream. The voice package does not use FFmpegâ€”input must be WebM with Opus. Use yt-dlp or similar to get direct stream URLs from YouTube.",
        "code": "// URL (fetched and demuxed automatically)\nawait connection.play('https://example.com/audio.webm');\n\n// Or a Node.js ReadableStream of Opus\nawait connection.play(opusStream);",
        "language": "javascript"
      },
      {
        "title": "Getting Stream URLs from YouTube",
        "description": "Use youtube-dl-exec or yt-dlp to extract a WebM/Opus URL.",
        "code": "import youtubedl from 'youtube-dl-exec';\n\nconst result = await youtubedl(videoUrl, {\n  getUrl: true,\n  f: 'bestaudio[ext=webm][acodec=opus]/bestaudio[ext=webm]/bestaudio',\n}, { timeout: 15000 });\n\nconst streamUrl = String(result ?? '').trim();\nawait connection.play(streamUrl);",
        "language": "javascript"
      },
      {
        "title": "Stop and Leave",
        "description": "Stop playback and disconnect from the guild's voice channel.",
        "code": "const connection = voiceManager.getConnection(guildId);\nconnection?.stop();\nif (connection) voiceManager.leave(guildId);",
        "language": "javascript"
      },
      {
        "title": "LiveKit and serverLeave",
        "description": "If using LiveKit, the server may emit serverLeave. Listen and reconnect if needed.",
        "code": "connection.on?.('serverLeave', async () => {\n  try {\n    const conn = await voiceManager.join(channel);\n    await conn.play(streamUrl);\n  } catch (e) {\n    console.error('Auto-reconnect failed:', e);\n  }\n});",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "events",
    "slug": "events",
    "title": "Events",
    "description": "Listen to gateway events with client.on. Handle messages, guild updates, voice state changes, and more.",
    "category": "events",
    "sections": [
      {
        "title": "Basic Usage",
        "description": "Use client.on(Events.X, handler) to subscribe to events. Handlers receive event-specific payloads.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.Ready, () => {\n  console.log('Bot is ready!');\n});\n\nclient.on(Events.MessageCreate, async (message) => {\n  console.log(message.content);\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Common Events",
        "description": "Essential events for most bots.",
        "code": "// Bot finished loading\nclient.on(Events.Ready, () => {});\n\n// New message (DM or guild)\nclient.on(Events.MessageCreate, async (message) => {});\n\n// Reaction events\nclient.on(Events.MessageReactionAdd, (data) => {});\nclient.on(Events.MessageReactionRemove, (data) => {});\n\n// Guild joined/left/updated\nclient.on(Events.GuildCreate, (guild) => {});\nclient.on(Events.GuildDelete, (guild) => {});\n\n// Channel created/updated/deleted\nclient.on(Events.ChannelCreate, (channel) => {});\nclient.on(Events.ChannelDelete, (channel) => {});\n\n// Member joined/left/updated\nclient.on(Events.GuildMemberAdd, (member) => {});\nclient.on(Events.GuildMemberRemove, (member) => {});\n\n// Voice state changed (for @fluxerjs/voice)\nclient.on(Events.VoiceStateUpdate, (data) => {});\nclient.on(Events.VoiceServerUpdate, (data) => {});",
        "language": "javascript"
      },
      {
        "title": "Reaction Events",
        "description": "Listen for when users add or remove reactions. The payload includes message_id, channel_id, user_id, and emoji (name and optional id for custom emojis). Use MessageReactionRemoveAll and MessageReactionRemoveEmoji for moderator actions.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageReactionAdd, (data) => {\n  const { message_id, channel_id, user_id, emoji } = data;\n  const emojiStr = emoji.id ? `<:${emoji.name}:${emoji.id}>` : emoji.name;\n  console.log(`User ${user_id} reacted with ${emojiStr} on message ${message_id}`);\n\n  // Filter for specific message (e.g. poll) or emoji\n  if (data.emoji.name === 'ðŸ‘') {\n    console.log('Someone voted yes!');\n  }\n});\n\nclient.on(Events.MessageReactionRemove, (data) => {\n  const { message_id, user_id, emoji } = data;\n  console.log(`User ${user_id} removed ${emoji.name} from message ${message_id}`);\n});\n\nclient.on(Events.MessageReactionRemoveAll, (data) => {\n  console.log(`All reactions cleared from message ${data.message_id}`);\n});\n\nclient.on(Events.MessageReactionRemoveEmoji, (data) => {\n  console.log(`All ${data.emoji.name} reactions removed from message ${data.message_id}`);\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Error Handling",
        "code": "client.on(Events.Error, (err) => {\n  console.error('Client error:', err);\n});",
        "language": "javascript"
      }
    ]
  },
  {
    "id": "prefix-commands",
    "slug": "prefix-commands",
    "title": "Prefix Commands",
    "description": "Handle !commands by listening to MessageCreate and parsing the content.",
    "category": "events",
    "sections": [
      {
        "title": "Basic Structure",
        "description": "Check for a prefix, split args, and dispatch to command handlers.",
        "code": "import { Client, Events } from '@fluxerjs/core';\n\nconst PREFIX = '!';\nconst client = new Client({ intents: 0 });\n\nclient.on(Events.MessageCreate, async (message) => {\n  if (message.author.bot || !message.content) return;\n  if (!message.content.startsWith(PREFIX)) return;\n\n  const args = message.content.slice(PREFIX.length).trim().split(/\\s+/);\n  const command = args.shift()?.toLowerCase();\n\n  if (command === 'ping') {\n    await message.reply('Pong!');\n  }\n  if (command === 'hello') {\n    const name = args[0] ?? 'there';\n    await message.reply(`Hello, ${name}!`);\n  }\n});\n\nawait client.login(process.env.FLUXER_BOT_TOKEN);",
        "language": "javascript"
      },
      {
        "title": "Guild-Only Commands",
        "code": "if (!message.guildId) {\n  await message.reply('This command only works in a server.');\n  return;\n}",
        "language": "javascript"
      }
    ]
  }
]
